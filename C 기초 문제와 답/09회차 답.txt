[문제] 아래의 코드에서 선언된 함수를 정의해 보세요.

#include <stdio.h>
#include <string.h>

/*
함수명         : intCompare
파라미터    :
  p1, p2    : 비교할 int형 데이터 저장되어 있는 주소
반환 값        :
  첫 번째 포인터의 값이 크면 양수,
  작으면 음수, 같으면 0을 반환
설명      : 두 포인터가 가리키는 값을 비교 값을 반환하는 함수
*/
int intCompare(void* p1, void* p2) {
    return *(int*)p1 - *(int*)p2;
}

/*
함수명 : intSwap
파라미터    :
  p1, p2    : 교환할 정수형 데이터가 저장된 주소
반환 값        :
  없음
설명      : 두 포인터가 가리키는 값을 교환하는 함수
*/
void intSwap(void* p1, void* p2) {
    int tmp = *(int*)p1;
    *(int*)p1 = *(int*)p2;
    *(int*)p2 = tmp;
}


/*
함수명     : intPrinter
파라미터    :
  p     : 출력할 정수 값 저장 주소
반환 값        : 없음
설명      : 포인터가 가리키는 값을 출력하는 함수
*/
void intPrinter(void* p) {
    printf("%d ", *(int*)p);
}

/*
함수명     : print
파라미터    :
  ptr       : 출력 데이터가 저장된 배열 주소
  size      : 배열 원소 하나의 크기
  count     : 배열 원소의 수
  printer   : 배열 원소 출력 함수
반환 값        : 없음
설명      : 포인터가 가리키는 배열의 값을 출력하는 Generic 함수
*/
void print(void* ptr, int size, int count, void (*printer)(void*)) {
    for (int i=0 ; i<count ; i++) {
        printer((char*)ptr + (i * size));
    }
    printf("\n");
}


/*
함수명     : sort
파라미터    :
  ptr       : 배열의 시작 주소
  size      : 배열 원소 하나의 크기(Byte)
  count     : 배열 원소의 수
  compare   : 비교함수
  swap      : 교환함수
반환 값        : 없음
설명      : 포인터가 가리키는 배열의 값을 정렬하는 Generic 함수
*/
void sort(void* ptr, int size, int count, int(*compare)(void*, void*), void (*swap)(void*, void*)) {
    for (int i=0 ; i<(count - 1) ; i++) {
        for (int j=(i+1) ; j<count ; j++) {
            void* pi = (char*)ptr + (i * size);
            void* pj = (char*)ptr + (j * size);
            if (compare(pi, pj) > 0) {
                swap(pi, pj);
            }
        }
    }
}


// main() 함수
int main() {
    int intArray[] = { 3, 5, 1, 2, 4 };
    int intSize = (int)sizeof(intArray[0]);
    int intCount = (int)(sizeof(intArray) / sizeof(intArray[0]));
    print(intArray, intSize, intCount, intPrinter);
    sort(intArray, intSize, intCount, intCompare, intSwap);
    print(intArray, intSize, intCount, intPrinter);
    return 0;
}


실행결과>
3 5 1 2 4
1 2 3 4 5
