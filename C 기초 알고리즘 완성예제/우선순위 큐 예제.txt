#include "stdafx.h"

#include <stdio.h>
#include <stdlib.h>

// 에러 메시지 출력을 위한 매크로 함수
#define PRINT_ERROR(msg) fprintf(stderr, "[%s : %4d] %s\n", __FUNCTION__, __LINE__, (msg))

// 부울 상수 정의 및 타입 재정의
typedef enum { FALSE, TRUE } bool_t;

// 우선순위 큐 관리 구조체 자료형의 선언
typedef struct {
	int* data;
	int rear;
	int size;
} queue_t;

// 정수 값 교환을 위한 함수
void swap(int* x, int* y) {
	int tmp = *x;
	*x = *y;
	*y = tmp;
};

bool_t is_empty(queue_t* pQ) {
	return (pQ->rear == 0 ? TRUE : FALSE);
}

bool_t is_full(queue_t* pQ) {
	return (pQ->rear >= pQ->size ? TRUE : FALSE);
}

queue_t* init(queue_t* pQ, int size) {
	pQ->data = (int*)calloc(size + 1, sizeof(int));
	if (pQ->data == NULL) {
		PRINT_ERROR("큐 데이터 저장소 동적할당에 실패하였습니다.");
		return NULL;
	}
	pQ->rear = 0;
	pQ->size = size;
	return pQ;
}

void printQueue(queue_t* pQ) {
	for (int i = 1; i <= pQ->rear; i++) {
		printf("%d ", pQ->data[i]);
	}
	printf("\n");
}

bool_t enQueue(queue_t* pQ, int data) {
	if (is_full(pQ)) {
		PRINT_ERROR("큐가 가득 찼습니다.\n");
		return FALSE;
	}
	int pos = ++pQ->rear;
	pQ->data[pos] = data;
	while ((pos > 1) && (pQ->data[pos] > pQ->data[pos / 2])) {
		swap(pQ->data + pos, pQ->data + (pos / 2));
		pos = pos / 2;
	}
	return TRUE;
}

int deQueue(queue_t* pQ) {
	if (is_empty(pQ)) {
		PRINT_ERROR("큐에 저장된 데이터가 없습니다.\n");
		errno = 1;
		return 0;
	}
	int pos = 1;
	int value = pQ->data[pos];
	pQ->data[pos] = pQ->data[pQ->rear--];
	while ((pos * 2) <= pQ->rear) {
		int child = pos * 2;
		if (((child + 1) <= pQ->rear) && (pQ->data[child] < pQ->data[child + 1]))
			child++;
		if (pQ->data[pos] >= pQ->data[child]) break;
		swap(pQ->data + pos, pQ->data + child);
		pos = child;
	}
	return value;
}

void destroy(queue_t* pQ) {
	free(pQ->data);
	pQ->rear = 0;
	pQ->size = 0;
}

int main() {
	int arr[] = { 5, 9, 2, 10, 4, 1, 8, 3, 7, 6, };
	int count = (int)(sizeof(arr) / sizeof(arr[0]));
	queue_t q = { NULL, 0, 0 };
	int data = 11;

	if (!init(&q, count)) exit(1);

	for (int i = 0; i<count; i++) {
		if (enQueue(&q, arr[i])) {
			printf("%d 값을 큐에 입력하였습니다.\n", arr[i]);
		}
	}
	if (enQueue(&q, data)) {
		printf("%d 값을 큐에 입력하였습니다.\n", data);
	}

	printQueue(&q);

	while (q.rear > 0) {
		errno = 0;
		data = deQueue(&q);
		if (errno != 0) break;
		printf("%d 값을 거냈습니다.\n", data);
	}
	printQueue(&q);

	errno = 0;
	data = deQueue(&q);
	if (errno == 0) {
		printf("%d 값을 거냈습니다.\n", data);
	}

	destroy(&q);

	return 0;
}

