#include "stdafx.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


// 에러 메시지 출력을 위한 매크로 함수
#define PRINT_ERROR(msg) fprintf(stderr, "[%s:%4d] %s\n", __FUNCTION__, __LINE__, (msg))

typedef enum { FALSE, TRUE } bool_t;

typedef struct {
	int* data;
	int front;
	int rear;
	int size;
} queue_t;

bool_t is_empty(queue_t* queue) {
	return (queue->front == queue->rear ? TRUE : FALSE);
}

bool_t is_full(queue_t* queue) {
	if (queue->front < queue->rear)
		return ((queue->rear + 1) == (queue->front + queue->size) ? TRUE : FALSE);
	return ((queue->rear + 1) == queue->front ? TRUE : FALSE);
}

queue_t* init(queue_t* queue, int count) {
	queue->data = (int*)malloc(sizeof(int) * (count + 1));
	if (queue->data == NULL) {
		PRINT_ERROR("큐공간 동적할당에 실패하였습니다.");
		return NULL;
	}
	memset(queue->data, 0, sizeof(int) * (count + 1));
	queue->front = 0;
	queue->rear = 0;
	queue->size = count + 1;
	return queue;
}

void print(queue_t* queue) {
	for (int i = queue->front; i != queue->rear; i = (i + 1) % queue->size) {
		printf("%d ", queue->data[i]);
	}
	printf("\n");
}

bool_t enqueue(queue_t* queue, int data) {
	if (is_full(queue)) {
		PRINT_ERROR("큐가 가득 찼습니다.");
		return FALSE;
	}

	queue->data[queue->rear++] = data;
	queue->rear %= queue->size;
	return TRUE;
}

int dequeue(queue_t* queue) {
	if (is_empty(queue)) {
		PRINT_ERROR("큐에 저장된 데이터가 없습니다.");
		errno = 1;
		return 0;
	}

	int dequeueData = queue->data[queue->front++];
	queue->front %= queue->size;
	return dequeueData;
}

void destroy(queue_t* queue) {
	free(queue->data);
	queue->data = NULL;
	queue->front = 0;
	queue->rear = 0;
	queue->size = 0;
}

int main() {
	int qSize = 10;
	queue_t queue = { NULL, 0, 0 };
	if (init(&queue, qSize) == NULL) {
		exit(1);
	}

	for (int j = 0; j < 10; j++) {
		for (int i = 1; i <= 11; i++) {
			enqueue(&queue, i);
		}
		print(&queue);
		

		for (int i = 0; i <= 10; i++) {
			errno = 0;
			int dequeueData = dequeue(&queue);
			if (errno > 0) break;
			printf("dequeue 데이터 : %d\n", dequeueData);
		}
	}

	destroy(&queue);

	return 0;
}
